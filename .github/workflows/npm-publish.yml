name: Publish Release (NPM Packages)

on:
  workflow_dispatch:
    inputs:
      channel:
        description: Release channel
        type: choice
        required: true
        default: stable
        options:
          - stable
          - beta

permissions:
  contents: write
  pull-requests: write
  id-token: write

jobs:
  publish:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: NPM Package Publishing
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: pnpm
          registry-url: https://registry.npmjs.org

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build
        run: pnpm build

      - name: Release Please (stable)
        if: github.event.inputs.channel != 'beta'
        uses: googleapis/release-please-action@v4
        with:
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json

      - name: Release Please (beta)
        if: github.event.inputs.channel == 'beta'
        uses: googleapis/release-please-action@v4
        with:
          config-file: release-please-config.beta.json
          manifest-file: .release-please-manifest-beta.json

      - name: Publish packages
        env:
          PUBLISH_TAG: ${{ github.event.inputs.channel == 'beta' && 'beta' || 'latest' }}
        run: |
          node -e "
          const { execSync } = require('node:child_process');
          const { readdirSync, readFileSync } = require('node:fs');
          const { join } = require('node:path');
          const { tmpdir } = require('node:os');

          const root = process.cwd();
          const packagesDir = join(root, 'packages');
          const entries = readdirSync(packagesDir, { withFileTypes: true })
            .filter((d) => d.isDirectory())
            .map((d) => d.name);

          const pkgs = [];
          for (const dirName of entries) {
            const relDir = join('packages', dirName);
            const pkgPath = join(root, relDir, 'package.json');
            const pkg = JSON.parse(readFileSync(pkgPath, 'utf8'));
            if (pkg.private) continue;
            const deps = {
              ...(pkg.dependencies || {}),
              ...(pkg.peerDependencies || {}),
              ...(pkg.optionalDependencies || {})
            };
            pkgs.push({
              dir: relDir,
              name: pkg.name,
              version: pkg.version,
              deps
            });
          }

          const nameToPkg = new Map(pkgs.map((p) => [p.name, p]));
          const graph = new Map();
          const indeg = new Map();
          for (const p of pkgs) {
            graph.set(p.name, []);
            indeg.set(p.name, 0);
          }
          for (const p of pkgs) {
            const internalDeps = Object.keys(p.deps || {}).filter((n) => nameToPkg.has(n));
            for (const depName of internalDeps) {
              graph.get(depName).push(p.name);
              indeg.set(p.name, indeg.get(p.name) + 1);
            }
          }

          const queue = [];
          for (const [name, deg] of indeg.entries()) {
            if (deg === 0) queue.push(name);
          }
          const order = [];
          while (queue.length) {
            const name = queue.shift();
            order.push(name);
            for (const next of graph.get(name)) {
              indeg.set(next, indeg.get(next) - 1);
              if (indeg.get(next) === 0) queue.push(next);
            }
          }
          if (order.length !== pkgs.length) {
            console.log('Warning: dependency cycle detected; falling back to directory order.');
            order.length = 0;
            for (const p of pkgs) order.push(p.name);
          }

          const tag = process.env.PUBLISH_TAG || 'latest';
          for (const name of order) {
            const p = nameToPkg.get(name);
            const full = p.name + '@' + p.version;
            let exists = true;
            try {
              execSync('npm view ' + full + ' version', { stdio: 'ignore' });
            } catch {
              exists = false;
            }
            if (exists) {
              console.log('Skipping ' + full + ' (already on npm)');
              continue;
            }
            const selector = './' + p.dir;
            const packDir = join(tmpdir(), 'npm-pack-' + Date.now());
            execSync('mkdir -p ' + packDir);

            console.log('Packing ' + selector + '...');
            const packCmd = 'pnpm --dir ' + selector + ' pack --pack-destination ' + packDir;
            execSync(packCmd, { stdio: 'inherit' });

            const tarballName = p.name.startsWith('@')
              ? p.name.slice(1).replace('/', '-') + '-' + p.version + '.tgz'
              : p.name + '-' + p.version + '.tgz';
            const tarballPath = join(packDir, tarballName);

            console.log('Publishing ' + tarballPath + ' as ' + full + '...');
            const cmd = 'npm publish ' + tarballPath + ' --provenance --access public --tag ' + tag;
            execSync(cmd, { stdio: 'inherit' });
          }
          "
