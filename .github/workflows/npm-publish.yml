name: Publish Release (NPM Packages)

on:
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

jobs:
  publish:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: NPM Package Publishing
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: pnpm

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build
        run: pnpm build

      - name: Publish packages
        run: |
          unset NODE_AUTH_TOKEN
          npm config delete //registry.npmjs.org/:_authToken || true
          npm config delete always-auth || true
          node -e "
          const { execSync } = require('node:child_process');
          const { readdirSync, readFileSync } = require('node:fs');
          const { join } = require('node:path');

          const root = process.cwd();
          const packagesDir = join(root, 'packages');
          const entries = readdirSync(packagesDir, { withFileTypes: true })
            .filter((d) => d.isDirectory())
            .map((d) => d.name);

          const pkgs = [];
          for (const dirName of entries) {
            const relDir = join('packages', dirName);
            const pkgPath = join(root, relDir, 'package.json');
            const pkg = JSON.parse(readFileSync(pkgPath, 'utf8'));
            if (pkg.private) continue;
            const deps = {
              ...(pkg.dependencies || {}),
              ...(pkg.peerDependencies || {}),
              ...(pkg.optionalDependencies || {})
            };
            pkgs.push({
              dir: relDir,
              name: pkg.name,
              version: pkg.version,
              deps
            });
          }

          const nameToPkg = new Map(pkgs.map((p) => [p.name, p]));
          const graph = new Map();
          const indeg = new Map();
          for (const p of pkgs) {
            graph.set(p.name, []);
            indeg.set(p.name, 0);
          }
          for (const p of pkgs) {
            const internalDeps = Object.keys(p.deps || {}).filter((n) => nameToPkg.has(n));
            for (const depName of internalDeps) {
              graph.get(depName).push(p.name);
              indeg.set(p.name, indeg.get(p.name) + 1);
            }
          }

          const queue = [];
          for (const [name, deg] of indeg.entries()) {
            if (deg === 0) queue.push(name);
          }
          const order = [];
          while (queue.length) {
            const name = queue.shift();
            order.push(name);
            for (const next of graph.get(name)) {
              indeg.set(next, indeg.get(next) - 1);
              if (indeg.get(next) === 0) queue.push(next);
            }
          }
          if (order.length !== pkgs.length) {
            console.log('Warning: dependency cycle detected; falling back to directory order.');
            order.length = 0;
            for (const p of pkgs) order.push(p.name);
          }

          const tag = 'latest';
          for (const name of order) {
            const p = nameToPkg.get(name);
            const full = p.name + '@' + p.version;
            let exists = true;
            try {
              execSync('npm view ' + full + ' version', { stdio: 'ignore' });
            } catch {
              exists = false;
            }
            if (exists) {
              console.log('Skipping ' + full + ' (already on npm)');
              continue;
            }
            const selector = './' + p.dir;
            console.log('Publishing ' + full + ' from ' + selector + '...');
            const cmd = 'npm publish --provenance --access public --tag ' + tag;
            execSync(cmd, { stdio: 'inherit', cwd: join(root, p.dir) });
          }
          "
